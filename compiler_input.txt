# Text to code converter
def @a 1
def @b 2
def @c 3
def @d 4
def @e 5
def @f 6
def @g 7
def @h 8
def @i 9
def @j A
def @k B
def @l C
def @m D
def @n E
def @o F
def @p 10
def @q 11
def @r 12
def @s 13
def @t 14
def @u 15
def @v 16
def @w 17
def @x 18
def @y 19
def @z 1A
def @_ 20
def @0 30
def @1 31
def @2 32
def @3 33
def @4 34
def @5 35
def @6 36
def @7 37
def @8 38
def @9 39
def @: 3A
def @as 2A
def @us 52

# Location of next character to draw
def cursor1 $00
def cursor2 $01

set cursor1 00
set cursor2 20

# Location of next text to be drawn to the screen
def text1 $02
def text2 $03

def keybuf1 $04
def keybuf2 $05

def KEYBUFBASE1 E0

def inbuf1 $06
def inbuf2 $07

str s_title "         g cpu emulator"
str s_cmd "cmd>"
str s_exit "exit"

mov ar s_title1
mov text1 ar
mov ar s_title2
mov text2 ar
call printstr

call newline

mov ar s_cmd1
mov text1 ar
mov ar s_cmd2
mov text2 ar
call printstr
call printus

mov ar keybuf1
mov inbuf1 ar
mov ar keybuf2
mov inbuf2 ar

loc mainloop
call keyprocess
jmp mainloop

halt

####### STREQUALS function ########
# Returns 1 if strings are equal
# Ar: Zero-page String 1
# $text: Zero-page String 2
# Br: Char code to stop on (00 for default)
#
# peek 1: Zero-page string 1
# peek 2: char code to stop on
# peek 3: local var to hold returned char
# peek 4: local var to hold offset
loc strequals

push ar
swp
push ar
push ar
mov ar 0
push ar
swp
mov br 0
io ar

loc strequals_start
ldz ar
io ar
poke 3
ldz text1
io ar
swp
peek 3
sub br
io ar
# Are the strings different?
jnz strequals_end
# Are we at the end?
clc
add br
jnz strequals_nonzero
# Both chars end in 00, return 1
mov ar 1
ret
loc strequals_nonzero
peek 2
sub br
jnz strequals_nonstop
# Both chars end in stop char, return 1
clc
mov ar 1
ret
loc strequals_nonstop
# Not 00 or stop char, continue
peek 4
inc ar
poke 4
swp
peek 1
jmp strequals_start

loc strequals_end
# Strings are different. Is the difference only in the ending char?
clc
add br
add 0
jz strequals_end_onezero
# Is the other one zero?
clc
swp
add 0
jz strequals_end_onezero
# Strings are different and neither ending is 00 so they really are different, return 0
mov ar 0
ret
loc strequals_end_onezero
# Is the other char the ending char?
peek 2
swp
sub br
jz strequals_end_match
# One char is 00, but the other isn't stop char, return 0
mov ar 0
ret

loc strequals_end_match
# One char is 00, one is stop char, return 1
mov ar 1
ret


####### PARSEINPUT function #######
loc parseinput
# TODO: Fix strcompare
ret

# Was exit typed?
mov ar s_exit1
mov text1 ar
mov ar s_exit2
mov text2 ar
mov ar inbuf1
call strequals
add 0
jnz parseinput_exit

# No recognized command
mov ar keybuf1
mov inbuf1 ar
mov ar keybuf2
mov inbuf2 ar

ret

loc parseinput_exit
io br
mov ar keybuf1
mov inbuf1 ar
mov ar keybuf2
mov inbuf2 ar
halt
ret

ret


####### KEYPROCESS function ########
loc keyprocess

mov ar keybuf1
mov br inbuf1
clc
sub br
jnz keyprocess_getkey
# Key buffer hasn't moved, return
ret
loc keyprocess_getkey
# Input buffer is a 32-bit ring buffer
mov ar inbuf1
clc
inc ar
and 1F
or KEYBUFBASE1
mov inbuf1 ar
mov br 0
ldz inbuf1
add 0
jnz keyprocess_bs

mov ar @_
call printchar
call newline
# TODO: Add input parsing call
call parseinput

mov ar s_cmd1
mov text1 ar
mov ar s_cmd2
mov text2 ar
call printstr
call printus
ret

loc keyprocess_bs
sub 1F
jnz keyprocess_char

clc
mov ar @_
call printchar
mov ar cursor1
sub 2
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar
mov ar @_
call printchar
mov ar cursor1
dec ar
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar
mov ar inbuf1
sub 2
and 1F
or KEYBUFBASE1
mov inbuf1 ar
call printus
ret

loc keyprocess_char
clc
add 1F
call printchar
call printus

ret


####### DISPMEM function #######
# Display memory with locations printed
# Arguments:
# Ar: Number of 8-byte blocks to print
# $text: Starting location to print from
loc dispmem
push ar

loc dispmem_start
dec ar
jm dispmem_end
poke 1

mov ar text2
call printhex
mov ar text1
call printhex
mov ar @:
call printchar
mov ar 8
mov br @_
call printmem
call newline
mov ar text1
add 8
mov text1 ar
mov ar text2
add 0
mov text2 ar
peek 1
jmp dispmem_start

loc dispmem_end
ret


####### NEWLINE function #######
# Moves cursor to beginning of next line
loc newline
clc
mov ar cursor1
not ar
mov br 1F
and br
mov br cursor1
add br
add 1
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar
ret


####### PRINTHEX function #######
# Prints a hex byte passed in the A reg
loc printhex
push ar

mov br F0
and br
shr
shr
shr
shr
clc
mov br A
sub br
jm printhex_num1

# Print letter
add 1
jmp printhex_end1

loc printhex_num1
# Print number
clc
add 3A

loc printhex_end1
mov br 0
stz cursor1

peek 1

clc
mov br 0F
and br

mov br A
sub br
jm printhex_num2

# Print letter
add 1
jmp printhex_end2

loc printhex_num2
# Print number
clc
add 3A

loc printhex_end2
mov br 1
stz cursor1

mov ar cursor1
add 2
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar

ret


####### PRINTMEM function #######
# Prints Ar hex bytes pointed to by text1 and text2
# Max number of bytes is 255
# Arguments:
# $text: Location of memory to print
# Ar: Number of bytes to print
# Br: Character to print between bytes, 00 for no space
#
# BP1: Number of bytes to print
# BP2: Character to print between bytes, 00 for no space
# BP3: Number of bytes that have been printed

loc printmem
push ar
swp
push ar
push ar
swp
mov br 0

loc printmem_start
clc
sub br
jz printmem_end
ldz text1
swp
poke 3
swp
call printhex

peek 2
add 0
jz printmem_space
call printchar

loc printmem_space
peek 3
swp
inc br
peek 1
jmp printmem_start

loc printmem_end
ret


####### PRINTCHAR function #######
# Prints a single character to the string passed in A reg
loc printchar
clc
mov br 0
stz cursor1

mov ar cursor1
inc ar
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar
ret


####### PRINTUS function #######
# Prints the underscore showing where the next char will be written
loc printus
mov ar @us
call printchar
mov ar cursor1
dec ar
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar
clc
ret


####### PRINTSTR function #######
# Prints the string at text1 and text2 to the screen
# Final character of string must be 00
# Max string length is 255 characters
loc printstr
clc
mov br 0

loc startprint
ldz text1
add 0
jz endprint
stz cursor1
inc br
jmp startprint

loc endprint
mov ar cursor1
add br
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar
ret