# Text to code converter
def @a 1
def @b 2
def @c 3
def @d 4
def @e 5
def @f 6
def @g 7
def @h 8
def @i 9
def @j A
def @k B
def @l C
def @m D
def @n E
def @o F
def @p 10
def @q 11
def @r 12
def @s 13
def @t 14
def @u 15
def @v 16
def @w 17
def @x 18
def @y 19
def @z 1A
def @_ 20
def @0 30
def @1 31
def @2 32
def @3 33
def @4 34
def @5 35
def @6 36
def @7 37
def @8 38
def @9 39
def @: 3A
def @as 2A

# Location of next character to draw
def cursor1 $00
def cursor2 $01

set cursor1 00
set cursor2 20

# Location of next text to be drawn to the screen
def text1 $02
def text2 $03

str s_title "         g cpu emulator         "
str s_cmd "cmd>"

mov ar s_title1
mov text1 ar
mov ar s_title2
mov text2 ar
call printstr

call newline

mov ar s_cmd1
mov text1 ar
mov ar s_cmd2
mov text2 ar
call printstr

call newline

mov ar 7
call printchar

call newline

mov ar 4A
call printhex

call newline

mov ar 00
mov text1 ar
mov ar 01
mov text2 ar
mov ar 8
mov br @_
call printmem

call newline

mov ar A
call dispmem

halt

####### DISPMEM function #######
# Display memory with locations printed
# Arguments:
# Ar: Number of 8-byte blocks to print
# $text: Starting location to print from
loc dispmem
push ar

loc dispmem_start
dec ar
jm dispmem_end
poke 1

mov ar text2
call printhex
mov ar text1
call printhex
mov ar @:
call printchar
mov ar 8
mov br @_
call printmem
call newline
mov ar text1
add 8
mov text1 ar
mov ar text2
add 0
mov text2 ar
peek 1
jmp dispmem_start

loc dispmem_end
ret


####### NEWLINE function #######
# Moves cursor to beginning of next line
loc newline
clc
mov ar cursor1
not ar
mov br 1F
and br
mov br cursor1
add br
add 1
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar
ret


####### PRINTHEX function #######
# Prints a hex byte passed in the A reg
loc printhex
push ar

mov br F0
and br
shr
shr
shr
shr
clc
mov br A
sub br
jm printhex_num1

# Print letter
add 1
jmp printhex_end1

loc printhex_num1
# Print number
clc
add 3A

loc printhex_end1
mov br 0
stz cursor1

peek 1

clc
mov br 0F
and br

mov br A
sub br
jm printhex_num2

# Print letter
add 1
jmp printhex_end2

loc printhex_num2
# Print number
clc
add 3A

loc printhex_end2
mov br 1
stz cursor1

mov ar cursor1
add 2
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar

ret


####### PRINTMEM function #######
# Prints Ar hex bytes pointed to by text1 and text2
# Max number of bytes is 255
# Arguments:
# $text: Location of memory to print
# Ar: Number of bytes to print
# Br: Character to print between bytes, 00 for no space
#
# BP1: Number of bytes to print
# BP2: Character to print between bytes, 00 for no space
# BP3: Number of bytes that have been printed

loc printmem
push ar
swp
push ar
push ar
swp
mov br 0

loc printmem_start
clc
sub br
jz printmem_end
ldz text1
swp
poke 3
swp
call printhex

peek 2
add 0
jz printmem_space
call printchar

loc printmem_space
peek 3
swp
inc br
peek 1
jmp printmem_start

loc printmem_end
ret


####### PRINTCHAR function #######
# Prints a single character to the string passed in A reg
loc printchar
clc
mov br 0
stz cursor1

mov ar cursor1
inc ar
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar
ret


####### PRINTSTR function #######
# Prints the string at text1 and text2 to the screen
# Final character of string must be 00
# Max string length is 255 characters
loc printstr
clc
mov br 0

loc startprint
ldz text1
add 0
jz endprint
stz cursor1
inc br
jmp startprint

loc endprint
mov ar cursor1
add br
mov cursor1 ar
mov ar cursor2
add 0
mov cursor2 ar
ret